module FrameLoop
export frameLoop, cancelFrameLoop, getCentroids, Centroid, MachineMovement, findRotation, wick

struct Centroid
	x::Cint
	y::Cint
	weight::Cint
end

struct MachineMovement
	translation::ComplexF64		# pixels, presumably — TODO standardise
	rotation::Float64			# radians
end

j = im
° = 2π/360	# multiplicative degrees to radians conversion factor

#* user settings
const fps::Int = 25											# framerate, s⁻¹
const width::Int = 64*16									# multiples of 64 work best
const height::Int = 64*16

const rtspPort = 8554
const mtxPath = "cm3"

const searchMaxNumCentroids::Int = 200
const searchMaxBuf::Int = 5000
const searchGridStep::Int = 16

const keyingBoardMaskCutInOut::Tuple{Int, Int} = (150, 255)
const keyingComponentMaskCutInOut::Tuple{Int, Int} = (150, 255)

const accelCFileDir::String = "$(@__DIR__)"
const accelCFileName::String = "accel"
const accelCFilePath::String = "$accelCFileDir/$accelCFileName"
const accelLib::String = "$accelCFilePath.so"

#* derived parameters
const samplesLuma::Int = width*height
const samplesChroma::Int = samplesLuma÷4 					# 4:2:2
const samplesPerFrame::Int = samplesLuma + 2samplesChroma 	# YUV

#* commands
const cameraCommands::Vector{Cmd} = [
	`rpicam-vid --flush -t 0 --camera 0 --nopreview --codec yuv420 --framerate $fps --width $width --height $height --inline --listen -o -`
	`rpicam-vid --flush -t 0 --camera 1 --nopreview --codec yuv420 --framerate $fps --width $width --height $height --inline --listen -o -`
]

const ffmpegCommand::Cmd = `ffmpeg -f rawvideo -pix_fmt yuv420p -s:v $(width)x$(height) -i /dev/stdin -c:v libx264 -preset ultrafast -tune zerolatency -f rtsp rtsp://localhost:$rtspPort/$mtxPath`

const mediaMtxCommand::Cmd = `bash -c "cd stream/mediamtx; ./mediamtx"`

#* control
runFrameLoop::Bool = false
runFrameLoopLock::ReentrantLock = ReentrantLock()

#* public assets
visionCentroidsPrivate::Vector{Vector{Centroid}} = [fill(Centroid(-1,-1,-1), searchMaxNumCentroids) for _ in cameraCommands]
visionCentroidsLength::Int = 0
visionCentroidsLock::ReentrantLock = ReentrantLock()

#* helper functions
function writeCompileTimeConstantsFile()

	location = "$accelCFileDir/accel-compile-time-constants.h"
	content = """
	// AUTOGENERATED by FrameLoop.jl ($(read(`date`, String)|>strip))
	// Do not edit this file directly if you value your sanity...

	// frame size
	#define WIDTH $width
	#define HEIGHT $height

	// masking
	#define MASK_BOARD_CUT_IN $(keyingBoardMaskCutInOut[1])
	#define MASK_COMP_CUT_IN $(keyingComponentMaskCutInOut[1])
	#define MASK_BOARD_CUT_OUT $(keyingBoardMaskCutInOut[2])
	#define MASK_COMP_CUT_OUT $(keyingComponentMaskCutInOut[2])

	// centroids algorithm
	#define MAX_SEARCH_BUF $searchMaxBuf
	#define MAX_NUM_CENTROIDS $searchMaxNumCentroids
	#define GRID_STEP $searchGridStep

	// ENDS"""
	
	write(location, content)

end

function makeAccelerationAvailable()
	
	writeCompileTimeConstantsFile()
	run(`bash -c "cd '$accelCFileDir'; gcc -std=gnu2x -O3 -c $accelCFileName.c"`)
	run(`bash -c "cd '$accelCFileDir'; g++ -shared -o $accelCFileName.so $accelCFileName.o -lm -fPIC"`)
	
end

#* prepare
makeAccelerationAvailable()

# the intention is that you would call this with @async to spawn a thread
function frameLoop()
	global runFrameLoop, runFrameLoopLock
	global visionCentroidsPrivate, visionCentroidsLength, visionCentroidsLock

	#* ensure there isn't already an instance obviously running
	rfl = @lock runFrameLoopLock runFrameLoop
	if rfl return end
	
	#* preallocate frame buffers and mask buffers
	cameraFrames::Vector{Vector{UInt8}} = [zeros(UInt8, samplesPerFrame) for _ in cameraCommands]
	outputFrame::Vector{UInt8} = zeros(UInt8, samplesPerFrame)
	outputMasks::Vector{Matrix{UInt8}} = [zeros(UInt8, height, width) for _ in cameraCommands] #? BUGS is this the right order height,width?

	#* open resources
	mediamtxIo = open(mediaMtxCommand, "r")
	cameraIos = open.(cameraCommands, "r")
	ffmpegIo = open(ffmpegCommand, "r+")		# note must be writeable
	write(ffmpegIo, outputFrame)				# no clue, but it bugs out if I don't do this?!?!
	
	sleep(0.5)

	#* repeating loop
	@lock runFrameLoopLock runFrameLoop = true
	while @lock runFrameLoopLock runFrameLoop

		#* read frames into buffers
		readbytes!.(cameraIos, cameraFrames)

		#* recalculate output frame and masks
		# this function is written in C for speed
		# acts in place
		@ccall accelLib.acceleratedCompositingMaskingLoop(
			cameraFrames[1]::Ptr{UInt8},
			cameraFrames[2]::Ptr{UInt8},
			outputFrame::Ptr{UInt8},
			outputMasks[1]::Ptr{UInt8},
			outputMasks[2]::Ptr{UInt8}
		)::Cvoid
		
		#* dispatch composited frame to FFmpeg
		write(ffmpegIo, outputFrame)
		# write(ffmpegIo, cameraFrames[1])

		#* use masks to recalculate centroids
		@lock visionCentroidsLock for i in eachindex(cameraCommands)
			# also in C and also acts in place
			visionCentroidsLength = @ccall accelLib.acceleratedCentroidFinding(
				outputMasks[i]::Ptr{UInt8},
				visionCentroidsPrivate[i]::Ptr{UInt8}
			)::Cint
		end

	end

	#* close resources
	close(mediamtxIo)
	close.(cameraIos)
	close(cameraIo)

end

function cancelFrameLoop()
	global runFrameLoop, runFrameLoopLock
	@lock runFrameLoopLock runFrameLoop = false
end

function getCentroids(cameraNumber::Int)::Vector{Centroid}
	@lock visionCentroidsLock deepcopy(visionCentroidsPrivate[cameraNumber][1:visionCentroidsLength])
end

function findRotation(leads, pads ; referenceLeadIndex=1, resolution=3°, selectivity=5, plotting=false)
	# leads is a list of the lead centroids
	# pads is a list of the pad centroids
	
	reference = leads[1]
	pads .-= reference
	leads .-= reference

	binSize = resolution
	numBins = 360°/binSize |> round |> Int
	binSize = 360°/numBins
	binLabels = binSize .* ((1:numBins) .- 0.5)
	bins = zeros(Float64, numBins)

	leadCoords = [(abs(l), angle(l)) for l in leads]

	for p in pads

		rp = abs(p)
		φp = angle(p)
	
		# see which arg bands it might touch
		for (rl, φl) in leadCoords[2:end]
	
			# calculate the quality of the match
			radiusMismatch = rl - rp
			quality = sech(selectivity*radiusMismatch)
	
			# calculate the angle required for this match
			angle = φl - φp
			while angle < 0° angle += 360° end
			while angle >= 360° angle -= 360° end
	
			# find the relevant bin
			binNum = 1 + (angle/binSize |> floor |> Int)
	
			# store in the bin
			bins[binNum] += quality
	
		end
	
	end
	
	binOrdering = sortperm(bins, rev=true)
	rankedAngles = binLabels[binOrdering]

	# if the desired centre of rotation isn't the actual centre of rotation of the nozzle, it will move
	# calculate the required translation to "catch" it
	correctiveTranslation = @. centreOfRotation*(1-cis(rankedAngles))

	return MachineMovement.(correctiveTranslation, rankedAngles)[1:5]

end

function wick(leads, pads ; plotting=false)

	# STEP 0 — PREPARATION
	# find corresponding pad for each lead
	mapping = []
	for l in leads
		deltas = abs.(pads .- l)
		push!(mapping, argmin(deltas))
	end

	# variables to keep track of the movements we make (so we can apply them to the machine)
	trackedTranslation::ComplexF64 = 0	# all of this applied to the pads
	trackedRotation::Float64 = 0	# all of this applied to the leads

	# STEP 1 — REMOVE NET TRANSLATION
	# step 2 requires this gone first
	movements = pads[mapping].-leads
	meanMovement = mean(movements)
	pads .-= meanMovement
	trackedTranslation += meanMovement

	movements = leads.-pads[mapping]
	meanMovement = mean(movements)

	# STEP 2 — REMOVE ROTATION
	# no translational error on pads at present, so we can use them to calculate the centre of rotation
	centreOfRotation = mean(pads[mapping])

	# calculate rotational correction
	subtendedAngles = angle.(pads[mapping].-centreOfRotation) .- angle.(leads.-centreOfRotation)
	meanRotation = mean(subtendedAngles)

	# if the desired centre of rotation isn't the actual centre of rotation of the nozzle, it will move
	# calculate the required translation to "catch" it
	correctiveTranslation = centreOfRotation*(1-cis(meanRotation))

	# make these corrections
	leads .*= cis(meanRotation)
	trackedRotation += meanRotation
	pads .-= correctiveTranslation
	trackedTranslation += correctiveTranslation

	return MachineMovement(trackedTranslation, trackedRotation)
	
end

end # module FrameLoop